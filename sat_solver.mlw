module Sat
	use import int.Int
	use import list.List
	use import option.Option
	use list.Length as ListLength
	use import array.Array
	use array.Array as Array
	use import model.Model
	use model.Model as Model
	use int.MinMax as IntMax
	use list.NthNoOpt as ListNth
	use list.Mem as ListMem
	use import ref.Ref
	use array.NumOfEq as ArrayNum
	use import map.Const as Mapconst
	use map.Map as Map
	use map.Occ as Mapocc

	type clause = list (int, bool)
	type formula = list clause

	predicate valid_clause (c:clause) =
		forall j: int. 0 <= j < ListLength.length c ->
		 let (k, _) = ListNth.nth j c in
		 k >= 0

	predicate valid_formula (f:formula) =
		forall i: int. 0 <= i < ListLength.length f ->
			valid_clause (ListNth.nth i f)
	
	lemma sub_clause0:
	forall c:list (int, bool) .
	valid_clause c ->
			match c with
			| Nil -> true
			| Cons _ b ->
				(forall i:int. 0 <= i < ListLength.length b -> (
					ListNth.nth i b = ListNth.nth (i+1) c
					))
			end
	
	lemma sub_clause:
	forall c:clause .
		valid_clause c ->
			match c with
			| Nil -> true
			| Cons _ b ->
				valid_clause b
			end
	
	lemma sub_formula0:
	forall c:formula.
	valid_formula c ->
			match c with
			| Nil -> true
			| Cons _ b ->
				(forall i:int. 0 <= i < ListLength.length b -> (
					ListNth.nth i b = ListNth.nth (i+1) c
					))
			end
	
	
	lemma sub_formula:
	forall c:formula .
		valid_formula c ->
			match c with
			| Nil -> true
			| Cons _ b ->
				valid_formula b
			end

	predicate all_under_clause (c:clause) (i: int) =
			(forall j: int. 0 <= j < ListLength.length c ->
				let (k, _) = ListNth.nth j c in
				i >= k)
			/\ i >= 0
	predicate all_under (f:formula) (i: int) =
		(forall j: int. 0 <= j < ListLength.length f -> all_under_clause (ListNth.nth j f) i) /\ i >= 0

	type assignment = Mod_true | Mod_false | Undef

	type impl_model = {
		real_model: array assignment;
		ghost mutable model: model;
	} invariant { size self.model = Array.length self.real_model
		/\ forall i:int. 0 <= i < size self.model ->
				((self.real_model[i] = Mod_true -> get self.model i) /\ (self.real_model[i] = Mod_false -> not (get self.model i)))  }

	lemma formula_top:
		forall m: model. sat m Nil

	lemma formula_no_clause:
		forall m: model. not (sat m (Cons Nil Nil))


	let val_model () ensures {
	let f = (Cons (Cons (0, true) Nil) Nil) in
	
	ListLength.length f = 1 /\ sat result f
	} =
		empty

	let create_impl_model (s: int): impl_model
		requires { s >= 0 }
		ensures { size result.model = s /\ forall i: int. 0 <= i < s -> result.real_model[i] = Undef } =
		let m = Array.make s Undef in
		assert { ArrayNum.numof m Undef 0 s = s };
		{ real_model = m;
		  model = create s;
		  }

	let rec max_var (f: formula)
		requires { valid_formula f }
		ensures {
			all_under f result
						}
		variant {
			ListLength.length f }
						=
		let rec max_var_aux (f:clause)
			requires { valid_clause f }
			ensures { all_under_clause f result }
			variant { ListLength.length f }
		=
			match f with
			| Cons (i, _) b ->
				IntMax.max (max_var_aux b) i
			| Nil -> 0
			end
		in
		match f with
		| Nil -> 0
		| Cons a b ->
			let a = max_var_aux a in
			let b = max_var b in
			assert { a >= 0 };
			assert { b >= 0 };
			IntMax.max a b
		end

	(* Some lemmas for occ *)
	 lemma map_set0:
		forall mymap: Map.map int 'a, l m m' u: int, a: 'a. l <= m <= m' <= u ->
			Mapocc.occ a mymap l u = Mapocc.occ a mymap l m + Mapocc.occ a mymap m m' + Mapocc.occ a mymap m' u

	 lemma map_set1:
		forall mymap: Map.map int 'a, l m: int, a b: 'a. l <= m ->
			Mapocc.occ a mymap l m = Mapocc.occ a (Map.set mymap m b) l m
	 
	 lemma map_set2:
		forall mymap: Map.map int 'a, u m: int, a b: 'a. m <= u ->
			Mapocc.occ a mymap (m+1) u = Mapocc.occ a (Map.set mymap m b) (m+1) u
	
	lemma list_nth:
		forall i: int, l: list 'a. 0 <= i < ListLength.length l ->
			ListMem.mem (ListNth.nth i l) l
	
	lemma list_mem:
		forall a: 'a,l: list 'a.
			ListMem.mem a l -> exists i:int. a = ListNth.nth i l



	let is_sat (f:formula): option impl_model
		requires { valid_formula f }
		ensures {
			match result with
			| None -> (forall m: model. not (sat m f))
			| Some m -> sat m.model f
			end
			}
		=
		let i = max_var f in

		let m = create_impl_model (i+1) in

		let rec is_sat_aux (f:formula) (m: impl_model) (ghost mymap: Map.map int assignment) : bool
		writes { m.model, m.real_model }
		requires { i + 1  = size m.model /\ all_under f i /\ valid_formula f /\
		forall i:int. 0 <= i < size m.model -> Map.get mymap i = m.real_model[i]
		}
		variant { (ListLength.length f), Mapocc.occ Undef mymap 0 (size m.model) }
		ensures {
		(forall i:int. 0 <= i < size m.model -> Map.get mymap i <> Undef -> Map.get mymap i = m.real_model[i])
		/\	if result then
			    sat m.model f
			else
				(forall i: int. 0 <= i < size m.model -> m.real_model[i] = Map.get mymap i)
			}
		=
			match f with
			| Nil -> true
			| Cons a b ->
				let s = ListLength.length a in
				let valid = ref false in
				let undef_lit = ref None in
				let ghost valid_lit = ref 0 in
				for i = 0 to (s-1) do
					invariant {
						match !undef_lit with
						| None -> true
						| Some (var, _) -> m.real_model[var] = Undef /\ 0 <= var < size m.model
						end
					}
					invariant {
						if !valid then
						sat_clause m.model a
						/\ (let (v, b) = ListNth.nth !valid_lit a  in
							ListMem.mem (v, b) a /\ 0 <= !valid_lit < ListLength.length a /\
							if b then
								Map.get mymap v = Mod_true
							else
								Map.get mymap v = Mod_false)
						else true }


					let (var, va) = ListNth.nth i a in
					(*assert { all_under_clause a ((size m.model) - 1) };*)
					assert { 0 <= var < size m.model };
					let mod_va = m.real_model[var] in
					if mod_va = Undef then
						undef_lit := Some (var, va)
					else if (mod_va = Mod_true && va) || (mod_va = Mod_false && not va) then
						(
						assert { get m.model var = va /\ sat_clause m.model a };
						valid_lit := i;
						valid := true;)
				done;
				if !valid then
					is_sat_aux b m mymap
				else
					match !undef_lit with
					| Some (var, va) ->
						m.model <- set m.model var va;
						m.real_model[var] <- (if va then Mod_true else Mod_false);
						if is_sat_aux b m (Map.set mymap var (if va then Mod_true else Mod_false)) then
							true
						else
							(m.model <- set m.model var (not va);
							m.real_model[var] <- (if va then Mod_false else Mod_true);
							assert { Map.get mymap var = Undef };
							let ghost mm = (Map.set mymap var (if va then Mod_false else Mod_true)) in
							assert { forall i: int. 0 <= i < var -> Map.get mm i = Map.get mymap i};
							assert { forall i: int. var + 1 <= i <size m.model -> Map.get mm i = Map.get mymap i};
							assert { Mapocc.occ Undef mymap 0 (size m.model) = (Mapocc.occ Undef mymap 0 var) + (Mapocc.occ Undef mymap var (var+1)) + (Mapocc.occ Undef mymap (var+1) (size m.model)) };
							assert { Mapocc.occ Undef mymap (var+1) (size m.model) = Mapocc.occ Undef mm (var+1) (size m.model) };
							assert { Mapocc.occ Undef mymap 0 (size m.model) > Mapocc.occ Undef mm 0 (size m.model) };
							if is_sat_aux f m mm then
								true
							else
								(m.real_model[var] <- Undef;
								false))
					| None -> false
					end
			end
		in
		if is_sat_aux f m (Mapconst.const Undef) then Some m
		else None


end



